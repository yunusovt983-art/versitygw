// Copyright 2023 Versity Software
// This file is licensed under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package auth

import (
	"testing"
	"time"
)

func TestSecurityReportingSystem_GenerateAccessSummaryReport(t *testing.T) {
	mockLogger := &MockSecurityAuditLogger{}
	alertSystem := NewSecurityAlertSystem(mockLogger, nil, nil)
	metricsCollector := NewSecurityMetricsCollector(nil, alertSystem, nil)
	
	reportingSystem := NewSecurityReportingSystem(mockLogger, alertSystem, metricsCollector, &ReportingConfig{EnableAutoReports: false})

	// Add some mock events to the logger
	events := []*SecurityEvent{
		{
			Type:      EventTypeAuthSuccess,
			UserID:    "user1",
			IPAddress: "192.168.1.100",
			Success:   true,
			Timestamp: time.Now().Add(-1 * time.Hour),
			Details:   map[string]interface{}{"auth_method": "signature_v4"},
		},
		{
			Type:      EventTypeAuthFailure,
			UserID:    "user2",
			IPAddress: "192.168.1.101",
			Success:   false,
			Timestamp: time.Now().Add(-30 * time.Minute),
			Message:   "Invalid password",
			Details:   map[string]interface{}{"auth_method": "mfa"},
		},
		{
			Type:      EventTypeAuthSuccess,
			UserID:    "user1",
			IPAddress: "192.168.1.100",
			Success:   true,
			Timestamp: time.Now().Add(-15 * time.Minute),
			Details:   map[string]interface{}{"auth_method": "signature_v4"},
		},
	}

	mockLogger.events = events

	request := &ReportRequest{
		Type:   ReportTypeAccessSummary,
		Format: ReportFormatJSON,
		TimeRange: &TimeRange{
			Start: time.Now().Add(-2 * time.Hour),
			End:   time.Now(),
		},
		RequestedBy: "test-user",
	}

	report, err := reportingSystem.GenerateReport(request)
	if err != nil {
		t.Fatalf("Failed to generate report: %v", err)
	}

	if report.Type != ReportTypeAccessSummary {
		t.Errorf("Expected report type %s, got %s", ReportTypeAccessSummary, report.Type)
	}

	if report.GeneratedBy != "test-user" {
		t.Errorf("Expected generated by 'test-user', got '%s'", report.GeneratedBy)
	}

	// Verify report data
	data, ok := report.Data.(*AccessSummaryReport)
	if !ok {
		t.Fatalf("Expected AccessSummaryReport data type")
	}

	if data.TotalAccesses != 3 {
		t.Errorf("Expected 3 total accesses, got %d", data.TotalAccesses)
	}

	if data.SuccessfulAccesses != 2 {
		t.Errorf("Expected 2 successful accesses, got %d", data.SuccessfulAccesses)
	}

	if data.FailedAccesses != 1 {
		t.Errorf("Expected 1 failed access, got %d", data.FailedAccesses)
	}

	if data.UniqueUsers != 2 {
		t.Errorf("Expected 2 unique users, got %d", data.UniqueUsers)
	}

	if data.UniqueIPs != 2 {
		t.Errorf("Expected 2 unique IPs, got %d", data.UniqueIPs)
	}
}

func TestSecurityReportingSystem_GenerateAuthenticationLogReport(t *testing.T) {
	mockLogger := &MockSecurityAuditLogger{}
	alertSystem := NewSecurityAlertSystem(mockLogger, nil, nil)
	metricsCollector := NewSecurityMetricsCollector(nil, alertSystem, nil)
	
	reportingSystem := NewSecurityReportingSystem(mockLogger, alertSystem, metricsCollector, &ReportingConfig{EnableAutoReports: false})

	// Add mock authentication events
	events := []*SecurityEvent{
		{Type: EventTypeAuthSuccess, UserID: "user1", Success: true},
		{Type: EventTypeAuthFailure, UserID: "user2", Success: false},
		{Type: EventTypeMFASuccess, UserID: "user1", Success: true}, // Should be filtered out
	}
	mockLogger.events = events

	request := &ReportRequest{
		Type:        ReportTypeAuthenticationLog,
		Format:      ReportFormatJSON,
		RequestedBy: "test-user",
	}

	report, err := reportingSystem.GenerateReport(request)
	if err != nil {
		t.Fatalf("Failed to generate authentication log report: %v", err)
	}

	// Verify only authentication events are included
	data, ok := report.Data.([]*SecurityEvent)
	if !ok {
		t.Fatalf("Expected []*SecurityEvent data type")
	}

	if len(data) != 2 {
		t.Errorf("Expected 2 authentication events, got %d", len(data))
	}
}

func TestSecurityReportingSystem_GenerateSecurityAlertsReport(t *testing.T) {
	mockLogger := &MockSecurityAuditLogger{}
	alertSystem := NewSecurityAlertSystem(mockLogger, nil, nil)
	metricsCollector := NewSecurityMetricsCollector(nil, alertSystem, nil)
	
	reportingSystem := NewSecurityReportingSystem(mockLogger, alertSystem, metricsCollector, &ReportingConfig{EnableAutoReports: false})

	// Trigger some alerts
	alertSystem.TriggerAlert(AlertTypeBruteForce, AlertSeverityHigh, "Test Alert 1", "Description 1", map[string]interface{}{"user_id": "user1"})
	alertSystem.TriggerAlert(AlertTypeUserLocked, AlertSeverityMedium, "Test Alert 2", "Description 2", map[string]interface{}{"user_id": "user2"})

	request := &ReportRequest{
		Type:        ReportTypeSecurityAlerts,
		Format:      ReportFormatJSON,
		RequestedBy: "test-user",
	}

	report, err := reportingSystem.GenerateReport(request)
	if err != nil {
		t.Fatalf("Failed to generate security alerts report: %v", err)
	}

	data, ok := report.Data.([]*SecurityAlert)
	if !ok {
		t.Fatalf("Expected []*SecurityAlert data type")
	}

	if len(data) != 2 {
		t.Errorf("Expected 2 alerts, got %d", len(data))
	}
}

func TestSecurityReportingSystem_GenerateAuditTrailReport(t *testing.T) {
	mockLogger := &MockSecurityAuditLogger{}
	alertSystem := NewSecurityAlertSystem(mockLogger, nil, nil)
	metricsCollector := NewSecurityMetricsCollector(nil, alertSystem, nil)
	
	config := DefaultReportingConfig()
	config.EnableAutoReports = false // Disable auto reports for testing
	
	reportingSystem := NewSecurityReportingSystem(mockLogger, alertSystem, metricsCollector, config)

	// Add audit trail entries
	entries := []AuditTrailEntry{
		{
			ID:        "audit1",
			Timestamp: time.Now().Add(-1 * time.Hour),
			EventType: "login",
			Severity:  "info",
			UserID:    "user1",
			Result:    "success",
		},
		{
			ID:        "audit2",
			Timestamp: time.Now().Add(-30 * time.Minute),
			EventType: "logout",
			Severity:  "info",
			UserID:    "user1",
			Result:    "success",
		},
		{
			ID:        "audit3",
			Timestamp: time.Now().Add(-15 * time.Minute),
			EventType: "failed_login",
			Severity:  "warning",
			UserID:    "user2",
			Result:    "failure",
		},
	}

	for _, entry := range entries {
		reportingSystem.AddAuditEntry(entry)
	}

	request := &ReportRequest{
		Type:        ReportTypeAuditTrail,
		Format:      ReportFormatJSON,
		RequestedBy: "test-user",
	}

	report, err := reportingSystem.GenerateReport(request)
	if err != nil {
		t.Fatalf("Failed to generate audit trail report: %v", err)
	}

	data, ok := report.Data.(*AuditTrailReport)
	if !ok {
		t.Fatalf("Expected *AuditTrailReport data type")
	}

	if data.TotalEvents != 3 {
		t.Errorf("Expected 3 total events, got %d", data.TotalEvents)
	}

	if data.EventsByType["login"] != 1 {
		t.Errorf("Expected 1 login event, got %d", data.EventsByType["login"])
	}

	if data.EventsBySeverity["info"] != 2 {
		t.Errorf("Expected 2 info events, got %d", data.EventsBySeverity["info"])
	}

	if len(data.Events) != 3 {
		t.Errorf("Expected 3 events in report, got %d", len(data.Events))
	}
}

func TestSecurityReportingSystem_GenerateComplianceReport(t *testing.T) {
	mockLogger := &MockSecurityAuditLogger{}
	alertSystem := NewSecurityAlertSystem(mockLogger, nil, nil)
	metricsCollector := NewSecurityMetricsCollector(nil, alertSystem, nil)
	
	reportingSystem := NewSecurityReportingSystem(mockLogger, alertSystem, metricsCollector, &ReportingConfig{EnableAutoReports: false})

	request := &ReportRequest{
		Type:        ReportTypeComplianceReport,
		Format:      ReportFormatJSON,
		RequestedBy: "test-user",
	}

	report, err := reportingSystem.GenerateReport(request)
	if err != nil {
		t.Fatalf("Failed to generate compliance report: %v", err)
	}

	data, ok := report.Data.(*ComplianceReport)
	if !ok {
		t.Fatalf("Expected *ComplianceReport data type")
	}

	if data.ComplianceFramework != "SOC2" {
		t.Errorf("Expected SOC2 framework, got %s", data.ComplianceFramework)
	}

	if data.OverallScore != 85.5 {
		t.Errorf("Expected overall score 85.5, got %f", data.OverallScore)
	}

	if len(data.Requirements) == 0 {
		t.Error("Expected at least one compliance requirement")
	}
}

func TestSecurityReportingSystem_GetReport(t *testing.T) {
	mockLogger := &MockSecurityAuditLogger{}
	alertSystem := NewSecurityAlertSystem(mockLogger, nil, nil)
	metricsCollector := NewSecurityMetricsCollector(nil, alertSystem, nil)
	
	reportingSystem := NewSecurityReportingSystem(mockLogger, alertSystem, metricsCollector, &ReportingConfig{EnableAutoReports: false})

	// Generate a report
	request := &ReportRequest{
		Type:        ReportTypeAccessSummary,
		Format:      ReportFormatJSON,
		RequestedBy: "test-user",
	}

	originalReport, err := reportingSystem.GenerateReport(request)
	if err != nil {
		t.Fatalf("Failed to generate report: %v", err)
	}

	// Retrieve the report
	retrievedReport, err := reportingSystem.GetReport(originalReport.ID)
	if err != nil {
		t.Fatalf("Failed to get report: %v", err)
	}

	if retrievedReport.ID != originalReport.ID {
		t.Errorf("Expected report ID %s, got %s", originalReport.ID, retrievedReport.ID)
	}

	// Try to get non-existent report
	_, err = reportingSystem.GetReport("non-existent-id")
	if err == nil {
		t.Error("Expected error when getting non-existent report")
	}
}

func TestSecurityReportingSystem_ListReports(t *testing.T) {
	mockLogger := &MockSecurityAuditLogger{}
	alertSystem := NewSecurityAlertSystem(mockLogger, nil, nil)
	metricsCollector := NewSecurityMetricsCollector(nil, alertSystem, nil)
	
	reportingSystem := NewSecurityReportingSystem(mockLogger, alertSystem, metricsCollector, &ReportingConfig{EnableAutoReports: false})

	// Generate multiple reports
	requests := []*ReportRequest{
		{Type: ReportTypeAccessSummary, Format: ReportFormatJSON, RequestedBy: "user1"},
		{Type: ReportTypeSecurityAlerts, Format: ReportFormatJSON, RequestedBy: "user2"},
		{Type: ReportTypeAccessSummary, Format: ReportFormatCSV, RequestedBy: "user1"},
	}

	for _, request := range requests {
		_, err := reportingSystem.GenerateReport(request)
		if err != nil {
			t.Fatalf("Failed to generate report: %v", err)
		}
	}

	// List all reports
	allReports := reportingSystem.ListReports(nil)
	if len(allReports) != 3 {
		t.Errorf("Expected 3 reports, got %d", len(allReports))
	}

	// Filter by type
	filters := map[string]interface{}{
		"type": ReportTypeAccessSummary,
	}
	filteredReports := reportingSystem.ListReports(filters)
	if len(filteredReports) != 2 {
		t.Errorf("Expected 2 access summary reports, got %d", len(filteredReports))
	}

	// Filter by generated_by
	filters = map[string]interface{}{
		"generated_by": "user1",
	}
	userReports := reportingSystem.ListReports(filters)
	if len(userReports) != 2 {
		t.Errorf("Expected 2 reports by user1, got %d", len(userReports))
	}
}

func TestSecurityReportingSystem_ExportReport(t *testing.T) {
	mockLogger := &MockSecurityAuditLogger{}
	alertSystem := NewSecurityAlertSystem(mockLogger, nil, nil)
	metricsCollector := NewSecurityMetricsCollector(nil, alertSystem, nil)
	
	config := DefaultReportingConfig()
	config.EnableAutoReports = false
	
	reportingSystem := NewSecurityReportingSystem(mockLogger, alertSystem, metricsCollector, config)

	// Generate a report
	request := &ReportRequest{
		Type:        ReportTypeAccessSummary,
		Format:      ReportFormatJSON,
		RequestedBy: "test-user",
	}

	report, err := reportingSystem.GenerateReport(request)
	if err != nil {
		t.Fatalf("Failed to generate report: %v", err)
	}

	// Test JSON export
	jsonData, err := reportingSystem.ExportReport(report.ID, ReportFormatJSON)
	if err != nil {
		t.Fatalf("Failed to export report as JSON: %v", err)
	}
	if len(jsonData) == 0 {
		t.Error("Expected non-empty JSON export")
	}

	// Test CSV export
	csvData, err := reportingSystem.ExportReport(report.ID, ReportFormatCSV)
	if err != nil {
		t.Fatalf("Failed to export report as CSV: %v", err)
	}
	if len(csvData) == 0 {
		t.Error("Expected non-empty CSV export")
	}

	// Test HTML export
	htmlData, err := reportingSystem.ExportReport(report.ID, ReportFormatHTML)
	if err != nil {
		t.Fatalf("Failed to export report as HTML: %v", err)
	}
	if len(htmlData) == 0 {
		t.Error("Expected non-empty HTML export")
	}

	// Test unsupported format
	_, err = reportingSystem.ExportReport(report.ID, "unsupported")
	if err == nil {
		t.Error("Expected error for unsupported export format")
	}
}

func TestSecurityReportingSystem_AuditTrail(t *testing.T) {
	mockLogger := &MockSecurityAuditLogger{}
	alertSystem := NewSecurityAlertSystem(mockLogger, nil, nil)
	metricsCollector := NewSecurityMetricsCollector(nil, alertSystem, nil)
	
	reportingSystem := NewSecurityReportingSystem(mockLogger, alertSystem, metricsCollector, &ReportingConfig{EnableAutoReports: false})

	// Add audit entries
	entries := []AuditTrailEntry{
		{EventType: "login", UserID: "user1", Severity: "info", Result: "success"},
		{EventType: "logout", UserID: "user1", Severity: "info", Result: "success"},
		{EventType: "failed_login", UserID: "user2", Severity: "warning", Result: "failure"},
		{EventType: "permission_denied", UserID: "user3", Severity: "error", Result: "failure"},
	}

	for _, entry := range entries {
		reportingSystem.AddAuditEntry(entry)
	}

	// Get all audit entries
	allEntries := reportingSystem.GetAuditTrail(nil)
	if len(allEntries) != 4 {
		t.Errorf("Expected 4 audit entries, got %d", len(allEntries))
	}

	// Filter by event type
	filters := map[string]interface{}{
		"event_type": "login",
	}
	loginEntries := reportingSystem.GetAuditTrail(filters)
	if len(loginEntries) != 1 {
		t.Errorf("Expected 1 login entry, got %d", len(loginEntries))
	}

	// Filter by user
	filters = map[string]interface{}{
		"user_id": "user1",
	}
	userEntries := reportingSystem.GetAuditTrail(filters)
	if len(userEntries) != 2 {
		t.Errorf("Expected 2 entries for user1, got %d", len(userEntries))
	}

	// Filter by severity
	filters = map[string]interface{}{
		"severity": "warning",
	}
	warningEntries := reportingSystem.GetAuditTrail(filters)
	if len(warningEntries) != 1 {
		t.Errorf("Expected 1 warning entry, got %d", len(warningEntries))
	}
}

func TestSecurityReportingSystem_ReportCleanup(t *testing.T) {
	mockLogger := &MockSecurityAuditLogger{}
	alertSystem := NewSecurityAlertSystem(mockLogger, nil, nil)
	metricsCollector := NewSecurityMetricsCollector(nil, alertSystem, nil)
	
	config := DefaultReportingConfig()
	config.MaxReports = 3 // Small limit for testing
	
	reportingSystem := NewSecurityReportingSystem(mockLogger, alertSystem, metricsCollector, config)

	// Generate more reports than the limit
	for i := 0; i < 5; i++ {
		request := &ReportRequest{
			Type:        ReportTypeAccessSummary,
			Format:      ReportFormatJSON,
			RequestedBy: "test-user",
		}
		_, err := reportingSystem.GenerateReport(request)
		if err != nil {
			t.Fatalf("Failed to generate report %d: %v", i, err)
		}
	}

	// Should only have max reports
	allReports := reportingSystem.ListReports(nil)
	if len(allReports) != 3 {
		t.Errorf("Expected 3 reports after cleanup, got %d", len(allReports))
	}
}

func TestSecurityReportingSystem_AuditTrailCleanup(t *testing.T) {
	mockLogger := &MockSecurityAuditLogger{}
	alertSystem := NewSecurityAlertSystem(mockLogger, nil, nil)
	metricsCollector := NewSecurityMetricsCollector(nil, alertSystem, nil)
	
	config := DefaultReportingConfig()
	config.MaxAuditEntries = 3 // Small limit for testing
	
	reportingSystem := NewSecurityReportingSystem(mockLogger, alertSystem, metricsCollector, config)

	// Add more audit entries than the limit
	for i := 0; i < 5; i++ {
		entry := AuditTrailEntry{
			EventType: "test_event",
			UserID:    "test-user",
			Severity:  "info",
			Result:    "success",
		}
		reportingSystem.AddAuditEntry(entry)
	}

	// Should only have max entries
	allEntries := reportingSystem.GetAuditTrail(nil)
	if len(allEntries) != 3 {
		t.Errorf("Expected 3 audit entries after cleanup, got %d", len(allEntries))
	}
}

func TestSecurityReportingSystem_RiskCalculations(t *testing.T) {
	// Test risk calculation functions
	metrics := &SecurityMetricsSnapshot{
		AuthAttempts:          100,
		AuthSuccesses:         80,
		AuthFailures:          20,
		SuspiciousActivities:  5,
		CurrentLockedUsers:    2,
	}

	authRisk := calculateAuthenticationRisk(metrics)
	if authRisk != 50.0 { // 20% failure rate = medium risk
		t.Errorf("Expected authentication risk 50.0, got %f", authRisk)
	}

	accessRisk := calculateAccessPatternRisk(metrics)
	if accessRisk != 30.0 { // 5 suspicious activities = low risk
		t.Errorf("Expected access pattern risk 30.0, got %f", accessRisk)
	}

	posture := calculateSecurityPosture(metrics)
	if posture != "Fair" { // Average of 50 and 30 = 40 = Fair
		t.Errorf("Expected security posture 'Fair', got '%s'", posture)
	}

	recommendations := generateRiskRecommendations(metrics)
	if len(recommendations) == 0 {
		t.Error("Expected at least one recommendation")
	}
}

func TestSecurityReportingSystem_TimeRangeFiltering(t *testing.T) {
	mockLogger := &MockSecurityAuditLogger{}
	alertSystem := NewSecurityAlertSystem(mockLogger, nil, nil)
	metricsCollector := NewSecurityMetricsCollector(nil, alertSystem, nil)
	
	reportingSystem := NewSecurityReportingSystem(mockLogger, alertSystem, metricsCollector, &ReportingConfig{EnableAutoReports: false})

	now := time.Now()
	
	// Add audit entries at different times
	entries := []AuditTrailEntry{
		{EventType: "old_event", Timestamp: now.Add(-2 * time.Hour)},
		{EventType: "recent_event", Timestamp: now.Add(-30 * time.Minute)},
		{EventType: "new_event", Timestamp: now.Add(-5 * time.Minute)},
	}

	for _, entry := range entries {
		reportingSystem.AddAuditEntry(entry)
	}

	// Filter by time range
	filters := map[string]interface{}{
		"start_time": now.Add(-1 * time.Hour),
		"end_time":   now,
	}

	recentEntries := reportingSystem.GetAuditTrail(filters)
	if len(recentEntries) != 2 {
		t.Errorf("Expected 2 recent entries, got %d", len(recentEntries))
	}
}